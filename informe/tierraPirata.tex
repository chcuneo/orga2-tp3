\section{Tierra Pirata}

\subsection{Manejo de memoria}

Para facilitar el manejo y armado de estructuras de paginación, creamos varias funciones en C. Como sabemos, cada directorio de paginas tiene 1024 entradas de descriptores de 4 bytes. Lo mismo sucede con los directorios de paginas, que también tienen 1024 entradas con descriptores de 4 bytes. El procesador, al buscar estas estructuras en memoria RAM, requiere que las mismas estén alineadas a 4 kB, dado que es el tamaño de pagina que carga en memoria cache. A continuación, una breve explicación de qué hacen las funciones exportadas al usuario (cabe destacar, hay numerosos comentarios en el código explicando las particularidades):

\begin{itemize}
\item \fun{int mmap(uint virtualAddress, uint physicalAddress, uint directoryBase, uchar readWrite, uchar supervisorUser)}: mapea la página donde se encuentra el address virtual a la página donde se encuentra el address físico, indicando permisos de escritura o de usuario según se indique por parámetro.

\item \fun{int munmap(uint directoryBase, uint virtualAddress)}: desmapea la página donde se encuentra el address virtual.

\item \fun{int remap(uint directoryBase, uint virtualAddress, uint physicalAddress)}: Remapea la página donde se encuentra el address virtual a la página donde se encuentra el address físico.

\item \fun{int isMapped(uint directoryBase, uint virtualAddress)}: Devuelve true si, y solo si, la página donde se encuentra el address virtual está presente, es decir, si el address virtual es accesible.

\item \fun{int mmu\_move\_codepage(uint directoryBase, uint codeBaseSrc, uint codeBaseDst)}: Copia 1 página de memoria (4 KB) desde el primer address virtual hacia le segundo address virtual. Es importante tener en cuenta los page boundaries, porque el código va a generar un page fault si no hay suficiente espacio.
\end{itemize}

No es necesario inicializar ninguna estructura particular fuera de estar a nivel kernel para utilizar estas funciones. Es importante marcar que por el esquema de memoria que armamos, estas funciones pueden actuar sobre cualquier directorio de tablas de página, aun sin ser el propio. Es decir, no es necesario cambiar el \reg{cr3} para manipular la paginación de una tarea, sino que basta con tener acceso de escritura al directorio y tablas de páginas correspondientes.

Además, escribimos funciones de inicialización tanto para la memoria del kernel como para la memoria de los piratas, las siguientes funciones deben ser llamadas en el proceso de inicialización de ambos:

\begin{itemize}
\item \fun{void mmu\_inicializar\_dir\_kernel()}: se ocupa de hacer el identity mapping de 4MB del kernel. Además, le mapea todo el mapa en modo escritura, lo que nos permitirá a futuro manejar todo el movimiento de los piratas.

\item \fun{int mmu\_inicializar\_dir\_pirata(uint directoryBase, uint pirateCodeBaseSrc, uint pirateCodeBaseDst)}: se ocupa de mapear el código del pirata a la dirección correspondiente, así como de copiar el código del pirata.
\end{itemize}

\subsection{Interrupciones}

\subsubsection{Reloj}

La interrupción de reloj comienza llamando la función \fun{scheduler\_tick}, que se ocupa de devolver el índice de la tarea en la \texttt{GDT} al que se debe ir. En caso de que se tenga que intercambiar de tarea, la rutina de atención de esta interrupción hace un \texttt{jump far} a la nueva tarea.

\subsubsection{Teclado}

Cuando hay una interrupción de teclado, la tecla que ha sido presionada se codifica con un \texttt{scan code} de 8 bits, que se guarda en el controlador de teclado. Estas se leen a través del puerto \hex{0x60} con la instrucción \texttt{in al, 0x60}. Una vez guardado el código, se llama a la función de C \fun{isr\_keyboard}, a la que se le pasa el código por pila respetando la convención C de 32 bits.

La función \fun{isr\_keyboard} luego le asigna diferentes funciones a las teclas \texttt{right\_shift}, \texttt{left\_shift} e \texttt{y}. Todos los scan codes están definidos en \texttt{keyboardcodes.h}.

\subsubsection{Syscall}
El sistema provee un servicio a las diferentes tareas mediante la interrupción \hex{0x46}. La misma le permite a las tareas usar de forma indirecta las siguientes funciones.
\begin{enumerate}
\item \fun{game\_syscall\_pirata\_mover}: Mueve al pirata de una posición a otra. Si el pirata que llamo a esta función es un minero, requiere que la pagina a la que  se quiere mover ya este paginada. Al moverse el pirata, también se mueve su código, y se debe también remappear la dirección \addr{0x400000} a la nueva dirección física donde el código se ha movido.

Si un pirata explorador al moverse encuentra un tesoro, se lanza un pirata minero automáticamente. Al mismo se le debe pasar la posición del tesoro por parámetro. Utilizando la convención C y el stack correspondiente a la nueva tarea, escribimos los parámetros en el stack de la dirección física de su respectivo codigo.

Cuando programamos esto tuvimos el siguiente problema. La interrupción al mover causaba un escalamiento de privilegios, pero seguíamos manteniendo el \reg{cr3} de la tarea que encontró el tesoro. Por esta razón no podíamos escribir en el stack de la nueva tarea y teníamos un \#GP Fault. Esto se debe a que las tareas tienen paginadas la memoria en solo lectura. Para resolver esto, simplemente cambiamos el \reg{cr3} por el del kernel antes de escribir en el stack y luego lo restauramos.

\item \fun{game\_syscall\_cavar}: Actualiza los puntajes y los atributos del tesoro correspondiente cuando un pirata minero cava. En caso de que se acaben las monedas del tesoro, el pirata se desaloja con la función \fun{game\_pirata\_exploto}
\item \fun{game\_syscall\_pirata\_posicion}: Devuelve la posición del pirata. La misma se codifica como y $<<$ 8 $|$ x en un entero.
\end{enumerate}

El Syscall se llama indirectamente a través de \texttt{inline asm}, que se ocupa de pasar los parámetros y llamar a la respectiva función. Al ejecutar esta interrupción hay un escalamiento de privilegios a nivel 0, lo que permite manipular la memoria y ejecutar funciones que no se podrían ejecutar desde una tarea (user), como por ejemplo manipular los directorios de pagina.

\pagebreak

\subsection{Scheduler}

El Scheduler es una función en C que es llamada por la interrupción de teclado. La misma de identificar la tarea que se debe ejecutar actualmente para respetar el siguiente diagrama:

\begin{figure}[H]
  \centering
    \includegraphics[width=0.7\textwidth]{images/scheduler}
  \caption{Diagrama de Tareas}
\end{figure}

Mantiene un contador para saber por cuantos ciclos de clock se ha ejecutado la tarea actual. A su vez, mantiene un flag para identificar a que jugador pertenece la ultima tarea que ha sido ejecutada. Para identificar que tarea ejecutar, itera sobre los piratas del jugador a partir del actual. Una tarea es ejecutada a lo sumo \texttt{SCHEDULER\_TASK\_TICKS} ciclos de clock. Esto esta definido en \texttt{defines.h}.

Cuando el contador alcanza el limite, el scheduler simplemente devuelve el indice en la GDT correspondiente a la TSS de la tarea que debe ser ejecutada. En caso de que no se deba cambiar de tarea, devuelve $-1$. La rutina de atención del reloj a partir de la salida de nuestro scheduler luego decide si debe hacer un \texttt{jump far}.

El intercambio con la tarea \texttt{Idle} cuando sucede un \texttt{Syscall} o cuando se desaloja a un pirata lo maneja la rutinas de assembler de los syscalls o de los handlers de interrupción en \texttt{isr.asm}.

\subsection{Estructuras}

Para mantener cuenta del estado del juego y de cada uno de los jugadores, creamos algunas estructuras definidas en \texttt{game.h}. Para saber que posiciones del mapa ya han sido paginadas, cada jugador mantiene un \texttt{bit\_map} con (\texttt{MAPA\_ALTO} * \texttt{MAPA\_ANCHO} / 8) chars. Cada bit corresponde a una pagina del mapa. De esta manera, al mover un jugador podemos fácilmente identificar que paginas deben ser mappeadas.

%\pagebreak


%\subsection{Funciones Auxiliares}
%Para facilitar la programación del juego, utilizamos las siguientes funciones auxiliares:

%\begin{enumerate}
%\item \fun{void game\_pirata\_erigir(pirata\_t *pirata, jugador\_t *j, uint tipo)}: 
%\item \fun{void game\_pirata\_habilitar\_posicion(jugador\_t *j, pirata\_t *pirata, int x, int y)}: 
%\item \fun{void game\_pirata\_exploto(uint id)}: 
%\item \fun{void game\_jugador\_setBitMapPos(jugador\_t *j, uint x, uint y, uchar val)}: 
%\item \fun{char game\_jugador\_getBitMapPos(jugador\_t *j, uint x, uint y)}: 
%\item \fun{void game\_pirata\_paginarPosMapa (pirata\_t *p, int x, int y)}: 
%\item \fun{void game\_jugador\_paginarPosMapa\_piratasExistentes (jugador\_t *j, int x, int y)}: 
%\item \fun{uint game\_xy2addressPhys(int x, int y)}: 
%\item \fun{uint game\_xy2addressVirt(int x, int y)}: 
%\item \fun{uint game\_posicion\_valida(int x, int y)}: 
%\item \fun{int game\_jugador\_taskAdress(jugador\_t *j, pirata\_t *p)}: 
%\item \fun{void game\_updateScreen(pirata\_t * p, jugador\_t * j, int x, int y)}: 
%\item \fun{uint game\_pirateIdtoDirectoryAddress(uint id)}: 
%\item \fun{pirata\_t* id\_pirata2pirata(uint pirate\_id)}: 
%\item \fun{uint game\_dir2xy(direccion dir, int *x, int *y)}: 
%\end{enumerate}

\subsection{Tareas}

\subsubsection{Idle}
La tarea Idle simplemente tiene un contador que sirve  para actualizar el reloj del juego.

\subsubsection{Explorador y Minero}
Estas tareas simplemente usan los syscalls para moverse por el mapa. No tocamos el código original de la cátedra. Utilizamos el código del minero del jugador A en el minero del jugador B.
